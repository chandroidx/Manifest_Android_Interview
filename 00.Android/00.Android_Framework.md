# Android Framework

## Q0) 안드로이드 프레임워크란 무엇인가요?
스마트폰과 태블릿과 같은 모바일 기기를 위해 주로 설계된 **오픈소스 운영 체제**.<br>
구글에 의해 개발 및 유지 관리되며 리눅스 커널에 기반함.<br>

<br>

**안드로이드 OS의 주요 특징**
1. [오픈 소스](https://source.android.com/) 및 커스텀화
2. SDK를 이용한 애플리케이션 개발
3. 풍부한 앱 생태계
4. 멀티태스킹 및 리소스 관리
5. 다양한 하드웨어 지원

<br>

**안드로이드 아키텍처**
[안드로이드 플랫폼 아키텍처](https://developer.android.com/guide/platform)는 모듈식으로 계층되어 있으며, 여러 구성 요소로 이루어져 있음.

<p align="center">
  <img width="295" height="340" alt="android-architecture" src="https://github.com/user-attachments/assets/666b774d-1169-4796-a4ad-923a04ac4968" />
</p>

- **리눅스 커널 (Linux Kernel)**
  - 안드로이드 운영체제의 기반을 형성함.
  - 하드웨어 추상화를 처리하여 소프트웨어와 하드웨어 간의 원활한 상호 작용을 보장함.
    
<br>

- **하드웨어 추상화 계층 (Hardware abstraction layer (HAL)**
  - 안드로이드의 Java API 프레임워크를 기기 하드웨어에 연결하는 표준 인터페이스를 제공함.
    
<br>

- **안드로이드 런타임 및 코어 라이브러리 (Android Runtime (ART) 및 Core Libraries)**
  - Kotlin이나 Java에서 컴파일된 바이트코드를 사용하여 애플리케이션을 실행함.
  - 최적화된 성능을 위해 Ahead-of-Time (AOT<sup>1</sup>) 및 Just-in-Time (JIT<sup>2</sup>) 컴파일을 지원함.
    
<br>

- **네이티브 C/C++ 라이브러리 모음 (Native C/C++ Libraries)**
  - 안드로이드 프레임워크와 애플리케이션에서 성능 집약적인 작업을 위해 직접 사용됨.
  - ex) OpenGL, SQLite
    
<br>

- **안드로이드 프레임워크 (Android Framework (APIS))**
  - 앱 개발을 위한 고수준 서비스와 API를 제공함.
  - 개발자가 안드로이드 시스템 기능을 효율적으로 활용할 수 있도록 지원함.
    
<br>

- **애플리케이션 (Applications)**
  - 시스템 앱과 안드로이드 SDK를 사용하여 생성된 서브파티 앱을 포함한 모든 유저 기반의 앱이 포함됨.
  - 사용자에게 다양한 기능을 제공하고, 각종 시스템들을 원활하게 운용하기 위해 하위 계층과 통신함.

<br>

<sub>
<b>1) Ahead-of-Time (AOT) 컴파일</b><br>
  - 코드가 런타임 전에 기계 코드로 컴파일 되어 실행 중 Just-In-Time (JIT) 컴파일이 필요 없는 프로세스.<br>
  - 최적화된 사전 컴파일된 바이너리를 생성하여 성능을 향상시키고 런타임 오버헤드를 줄임.<br>
</sub>
<br>
<sub>
<b>2) Just-In-Time (JIT) 컴파일</b><br>
  - 바이트코드가 실행 직전에 동적으로 기계 코드로 변환되는 런타임 프로세스.<br>
  - 런타임 환경은 실제 실행 패턴을 기반으로 코드를 최적화하여 자주 사용되는 코드 경로의 성능을 향상.<br>
</sub>

<br>

<br>

## Q1) 인텐트([Intent](https://developer.android.com/reference/android/content/Intent))란 무엇인가요?
수행될 작업에 대한 추상적인 설명.<br>
Activity, Service, BroadcastReceiver가 통신할 수 있도록 하는 **메시징 객체 역할**.<br>
브로드캐스트를 보내거나, Service를 시작하는데 사용됨.<br>
또한 **컴포넌트 간에 데이터를 전달**할 수 있어 안드로이드 시스템에서 근본이 되는 요소.<br>

<br>

**1. 명시적 Intent (Explicit Intent)**
- **정의**: 호출할 컴포넌트(Activity 또는 Service)를 직접 이름으로 지정하여 정확히 명시함.
- **사용 사례**: 대상 컴포넌트를 알고 있을 때 사용됨.
- **시나리오**: 동일한 앱 내에서 한 Activity에서 다른 Activity로 전환하는 경우.<br>
  
```kotlin
val intent = Intent(this, TargetActivity::class.java)
startActivity(intent)
```

<br>

**2. 암시적 Intent (Implicit Intent)**
- **정의**: 특정 컴포넌트를 지정하지 않고 수행할 일반적인 작업을 선언함.<br>시스템은 액션(action), 카테고리(category), 데이터(data)를 기반으로 어떤 컴포넌트가 Intent를 처리할 수 있는지 결정함.
- **사용 사례**: 다른 앱이나 시스템 컴포넌트가 처리할 수 있는 작업을 수행하려 할 때 유용함.
- **시나리오**: 브라우저에서 웹 페이지를 열거나 다른 앱과 콘텐츠를 공유하는 경우. (시스템이 Intent를 처리할 앱을 결정함)

```kotlin
val intent = Intent(Intent.ACTION_VIEW)
intent.data = Uri.parse("https://www.example.com")
startActivity(intent)
```

<br>

**🛠️ Summary**<br>
명시적 Intent는 대상 컴포넌트가 알려진 내부 앱 내비게이션에 사용됨.<br>
암시적 Intent는 대상을 직접 지정하지 않고 외부 앱이나 다른 컴포넌트가 처리할 수 있는 작업에 사용됨.<br>

<br>

>**💡 Pro Tips for Mastery : 인텐트 필터([Intent Filters](https://developer.android.com/guide/components/intents-filters))란 무엇인가요?** <br>
>앱 컴포넌트가 링크 열기나 브로드캐스트 처리와 같은 **특정 Intent에 어떻게 응답할 수 있는지를 정의함**.<br>
>Activity, Service 또는 BroadcastReceiver가 처리할 수 있는 **Intent 유형을 선언하는 필터** 역할을 하며, AndroidManifest.xml 파일에 명시됨.<br>
>각 intent filter는 들어오는 Intent와 정확히 일치시키기 위해 액션, 카테고리 및 데이터 유형을 포함할 수 있음.<br>

<br>

<p align="center">
  <img width="858" height="396" alt="intent-filters" src="https://github.com/user-attachments/assets/7c8b7260-42e3-4dd6-b978-fe4a6a7a27dc" />
</p>

<br>

<br>

## Q2) PendingIntent의 목적은 무엇인가요?
다른 애플리케이션이나 시스템 컴포넌트가 애플리케이션을 대신하여 미리 정의된 Intent를 나중에 실행할 수 있는 권한을 부여하는 또 다른 종류의 Intent.<br>
알림이나 서비스와의 상호작용과 같이 앱의 수명 주기를 벗어나 트리거되어야하는 작업에 특히 유용함.<br>

<br>

**PendingIntent**의 주요 특징
일반 Intent의 래퍼(wrapper) 역할을 하여 앱의 생명주기를 넘어서 지속될 수 있도록 함.<br>
```kotlin
val intent = Intent(this, MyActivity::class.java)
// FLAG_IMMUTABLE 또는 FLAG_MUTABLE 플래그 지정 필수 (Android 12+)
val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
  PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
} else {
  PendingIntent.FLAG_UPDATE_CURRENT
}
val pendingIntent = PendingIntent.getActivity(
  this,
  0, // requestCode
  intent,
  pendingIntentFlags
)

val notification = NotificationCompat.Builder(this, CHANNEL_ID)
  .setContentTitle("Title")
  .setContentText("Content")
  .setSmallIcon(R.drawable.ic_notification)
  .setContentIntent(pendingIntent) // 알림을 탭했을 때 트리거됨
  .setAutoCancel(true) // 탭하면 알림 자동 삭제
  .build()

NotificationManagerCompat.from(this).notify(NOTIFICATION_ID, notification)
```

<br>

PendingIntent는 동작 방식과 시스템 또는 다른 컴포넌트와의 상호 작용 방식을 제어하는 다양한 플래그를 지원함.
- **FLAG_UPDATE_CURRENT**: 기존 PendingIntent를 새 데이터로 업데이트 함.
- **FLAG_CANCEL_CURRENT**: 새 PendingIntent를 만들기 전에 기존 PendingIntent를 취소함.
- **FLAG_IMMUTABLE**: PendingIntent를 변경 불가능하게 만들어 수신자가 수정하는 것을 방지함. (⭐️Android 12+)
- **FLAG_ONE_SHOT**: PendingIntent가 한 번만 사용될 수 있도록 보장함.

<br>

**사용 사례**
1. **노티피케이션 (Notifications)**: 사용자가 노티피케이션을 탭했을 때 Activity를 여는 것과 같은 작업을 허용함.
2. **알람 (Alarms)**: AlarmManager를 사용하여 작업을 예약함.
3. **서비스 (Services)**: 백그라운드 작업을 위해 ForegroundService 또는 BroadcastReceiver에 작업을 위임함.

<br>

**보안 고려 사항**<br>
악의적인 앱이 기본 Intent를 수정하는 것을 방지하기 위해 PendingIntent에는 항상 FLAG_IMMUTABLE을 설정해야 함.<br>

<br>

**🛠️ Summary**<br>
PendingIntent는 앱이 활성 상태가 아닐 때에도 앱과 시스템 컴포넌트 또는 다른 앱 간의 원활한 통신을 가능하게 하는 안드로이드의 핵심 메커니즘.<br>
플래그와 권한을 신중하게 관리함으로써 지연된 작업의 안전하고 효울적인 실행을 보장할 수 있음.

<br>

<br>

## Q3) Serializable과 Parcelable의 차이점은 무엇인가요?
모두 다른 컴포넌트 간에 데이터를 전달하는 데 사용되는 메커니즘이지만, 성능과 구현 측면에서 다르게 작동함.

<br>

**Serializable**
- **Java 표준 인터페이스 (Java Standard Interface)**: 객체를 **바이트 스트림**으로 변환하여 Activity 간에 전달하거나 디스크에 쓸 수 있도록 하는 표준 Java 인터페이스
- **리플렉션 기반 (Reflection-Based)**: 시스템이 런타임에 클래스와 필드를 동적으로 검사하여 객체를 직렬화함.
- **성능**: 리플렉션이 느린 프로세스이기 때문에 Parcelable에 비해 느림. 또한 직렬화 중에 많은 임시 객체를 생성하여 메모리 오버헤드를 증가시킴.
- **사용 사례**: 성능이 중요하지 않거나 안드로이드 특정 코드가 아닌 코드베이스를 다룰때 유용함.

<br>

**Parcelable**
- **안드로이드 기반 인터페이스(Android-Specific Interface)**: 안드로이드 컴포넌트 내에서 고성능 프로세스 간 통신(IPC<sup>3</sup>)를 위해 특별히 설계된 안드로이드 특정 인터페이스
- **성능**: 안드로이드에 최적화되어 있고 리플렉션에 의존하지 않기 때문에 Serializable보다 빠름. 많은 임시 객체 생성을 피하여 가비지 컬렉션을 최소화함.
- **사용 사례**: 성능이 중요한 안드로이드 데이터 전달, 특히 IPC나 Activity 또는 Service 간 데이터 전달에 선호됨.

<br>

최신 안드로이드 개발에서는 [kotlin-parcelize plugin](https://plugins.gradle.org/plugin/org.jetbrains.kotlin.plugin.parcelize)이 구현을 자동으로 생성하여 Parcelable 객체를 만드는 과정을 단순화함.<br>

<br>

```kotlin
import kotlinx.parcelize.Parcelize
import android.os.Parcelable

@Parcelize
class User(val firstName: String, val lastName: String, val age: Int): Parcelable
```

<br>

이 설정을 사용하면 writeToParcel과 같은 메서드를 재정의하거나 CREATOR를 구현할 필요가 없어 보일러 플레이트 코드를 크게 줄이고 가독성을 향상시킴.

<br>

>**💡 Additional Tips**<br>
>@Parcelize로 표기된 클래스가 원시 타입이 아니고, @Parcelize로 표기되지 않은 클래스를 프로퍼티로 포함하고 있다면, 다음 오류가 발생함.<br>
>**"Type is not directly supported by 'Parcelize'. Annotate the parameter type with '@RawValue' if you want it to be serialized using 'writeValue()'."**<br>
>이는 Parcelize 컴파일러 플러그인이 직렬화 중에 모든 속성을 평면화하려고 하기 때문에 발생하는 문제이며, 지원되지 않거나 인식되지 않는 유형은 명시적으로 표기해야함.<br>
>해당 문제를 해결하려면 모든 프로퍼티의 타입이 원시 타입 또는 @Parcelize 표기된 타입이거나, 혹은 수동으로 직렬화를 처리하기를 원한다면 프로퍼티에 @RawValue 어노테이션을 추가하고 수동으로 직렬화 로직을 추가해야 함.<br>

<br>

**🛠️ Summary**
일반적으로 안드로이드 애플리케이션의 경우, 대부분의 사용 사례에서 더 나은 성능 때문에 **Parcelable**이 권장됨.<br>
- 더 간단한 경우나 성능에 중요하지 않은 작업을 처리할 때, 또는 안드로이드 컴포넌트 간에 데이터 교환 목적 등이 아닌 용도로 사용할 때는 Serializable을 사용할 수 있음.
- 성능이 중요한 안드로이드 기반 컴포넌트와 소통할 때는 Parcelable을 사용해야 함.

<br>

>**💡Pro Tips for Mastery: Parcel과 Parcelable이란 무엇인가요?** <br>
>Parcel은 안드로이드 애플리케이션의 다른 컴포넌트 간의 고성능 프로세스 간 통신(IPC)을 가능하게 하는 컨테이너 클래스.<br>
>주로 데이터를 마샬링<sup>4</sup>(직렬화, flattening)하고 언마샬링<sup>5</sup>(역직렬화, unflattening)하여 안드로이드의 IPC 경계를 넘어서 전달할 수 있도록 사용됨.<br>
>Parcel은 프로세스 간 통신(IPC) 메커니즘을 통해 직렬화된 데이터와 라이브 IBinder<sup>6</sup> 객체에 대한 참조를 모두 보내는 데 사용되는 컨테이너임.<br>
>고성능 IPC 전송을 위해 설계되었으며, 객체(Parcelable 인터페이스 사용)를 효율적으로 직렬화하고 컴포넌트 간에 전달할 수 있게 함.<br>
>Parcel은 범용 직렬화 도구가 아니며 영구 저장에 사용해서는 안됨. (내부 구현이 변경될 수 있어 이전 데이터를 읽을 수 없게 만들 수 있음.)<br><br>
>API에는 기본 데이터 유형, 배열 및 Parcelable 객체를 읽고 쓰는 다양한 메서드가 포함되어 있어 객체가 자신을 직렬화하고 필요할 때 재구성할 수 있음.<br>
>또한, 클래스 정보 쓰기를 생략하는 Parcelable 작업에 최적화된 메서드가 있어, 효율적인 데이터 처리를 위해 읽는 쪽에서 미리 유형을 알아야 함.<br><br>
>Parcelable은 객체를 직렬화하여 Parcel을 통해 전달할 수 있도록 하는 안드로이드에 특화된 인터페이스임.<br>
>Parcelable을 구현하는 객체는 Parcel에 쓰고 복원할 수 있어 안드로이드 컴포넌트 간에 복잡한 데이터를 전달하는 데 적합함.<br>

<br>

<sub>
<b>3) 프로세스 간 통신 (Inter-process communication, IPC)</b><br>
  - 서로 다른 프로세스가 서로 통신하고 데이터를 공유할 수 있도록 하는 메커니즘으로, 별도의 애플리케이션이나 시스템 서비스 간의 협업을 가능하게 함.<br>
  - 안드로이드에서는 <b>Binder</b>, <b>Intents</b>, <b>ContentProviders</b>, <b>Messenger</b>와 같은 컴포넌트를 통해 IPC가 이루어지며, 이는 프로세스 간 데이터 교환을 안전하고 효율적으로 가능하게 함.<br>
</sub>
<br>
<sub>
<b>4) 마샬링 (Marshaling)</b><br>
  - 객체나 데이터 구조를 네트워크를 통해 전송하거나 저장한 후 나중에 재구성할 수 있는 형식으로 변환하는 프로세스.<br>
  - 안드로이드에서는 일반적으로 <b>Binder</b>와 같은 메커니즘으로 전송하기 위해 데이터가 직렬화되는 프로세스 간 통신(IPC)에서 사용됨.<br>
</sub>
<br>
<sub>
<b>5) 언마샬링 (Unmarshaling)</b><br>
  - 직렬화된 형식의 데이터나 객체를 원래 형태로 다시 되돌리는 프로세스.<br>
  - 안드로이드에서는 <b>Binder</b>와 같은 메커니즘을 통해 전송된 데이터가 수신 프로세스에서 사용하기 위해 역직렬화되는 프로세스 간 통신(IPC)에서 자주 발생함.<br>
</sub>
<br>
<sub>
<b>6) IBinder</b><br>
  - 프로세스 간 통신(IPC)를 위핸 핵심 안드로이드 인터페이스.<br>
  - 클라이언트와 서비스와 같은 다른 컴포넌트 간의 저수준 통신 브리지 역할을 하여 원격으로 데이터를 교환하거나 메서드를 호출하여 상호 작용할 수 있도록 함.<br>
</sub>

<br>

<br>

## Q4) Context란 무엇이며 어떤 유형의 Context가 있나요?
애플리케이션의 **환경 또는 상태**를 나타내며 애플리케이션별 **리소스 및 클래스에 대한 접근** 제공.<br>
앱과 안드로이드 시스템 간의 브릿지 역할.<br>

<br>

**Application Context (애플리케이션 컨텍스트)** <br>
애플리케이션의 라이프 사이클과 연결되어 있으며 Activity나 Fragment와 독립적인 전역적이고 오래 지속되는 Context가 필요할 때 사용.<br>
- SharedPreferences나 데이터베이스와 같은 애플리케이션 전체 리소스에 접근하는 경우.
- 전체 앱 생명주기 동안 지속되어야 하는 BroadcastReceiver를 등록하는 경우.
- 앱 생명주기 동안 유지되는 라이브러리나 컴포넌트를 초기화하는 경우.

<br>

**Activity Context (액티비티 컨텍스트)** <br>
Activity의 생명주기와 연결되어 있음.<br>
Activity의 특정한 리소스 접근, 다른 Activity 시작, 레이아웃 인플레이션에 사용됨.<br>
- UI 컴포넌트를 생성 또는 업데이트하는 경우.
- 다른 Activity를 실행하는 경우.
- 현재 Activity 범위에 있는 리소스나 테마에 접근하는 경우.

**Service Context (서비스 컨텍스트)** <br>
Service의 생명주기와 연결되어 있음.<br>
주로 네트워크 작업 수행이나 음악 재생과 같은 백그라운드에서 실행되는 작업에 사용됨.<br>

<br>

**Broadcast Context (브로드캐스트 컨텍스트)** <br>
BroadcastReceiver가 호출될 때 제공됨.<br>
수명이 짧으며 일반적으로 특정 브로드캐스트에 응답하는데 사용됨.<br>

<br>

**Context의 일반적인 사용 사례** <br>
1. **리소스 접근**: getString() 또는 getDrawable()과 같은 메서드를 사용하여 문자열, 드로어블(Drawable), 치수(Dimension)와 같은 리소스에 대한 접근을 제공함.
2. **레이아웃 인플레이션**: LayoutInflater를 사용하여 XML 레이아웃을 뷰로 인플레이션하는 데 사용됨.
3. **액티비티 및 서비스 시작**: Activity(startActivity())와 Service(startService())를 시작하는데 사용됨.
4. **시스템 서비스 접근**: getSystemService()를 통해 ClipboardManager 또는 ConnectivityManager와 같은 시스템 수준 서비스에 대한 접근을 제공함.
5. **데이터베이스 및 SharedPreferences 접근**: SQLite 데이터베이스나 SharedPreferences와 같은 영구 저장 메커니즘에 접근하는 데 사용.

<br>

**🛠️ Summary**<br>
Context는 앱과 시스템 리소스 간의 상호 작용을 가능하게 하는 안드로이드 핵심 구성 요소.<br>
Application Context, Activity Context, Service Context, Broadcast Context와 같은 다양한 유형의 Context가 존재하며, 각각 다른 목적을 가지고 있음.<br>
Context를 적절하게 사용하면 효율적인 리소스 관리를 보장하고 메모리 누수나 크래시를 방지할 수 있으므로 올바른 Context를 선택해야하고 불필요하게 유지하지 않는 것이 중요험.<br>

<br>

>**💡Pro Tips for Mastery: Context 사용 시 주의할 점은 무엇인가요?** <br>
>Context는 안드로이드에서 리소스 접근데 편리한 메커니즘이지만, 부적절하게 사용하면 메모리 누수, 크래시 또는 비효율적인 리소스 처리와 같은 심각한 문제를 일으킬 수 있음.
>Activity 또는 Fragment에 대한 참조를 해당 생명주기 보다 오래 유지한다면 가비지 컬렉터가 Context 또는 관련 리소스에 대한 메모리를 회수할 수 없게 되어 메모리 누수로 이어질 수 있음.
>```kotlin
>object Singleton {
>  var context: Context? = null // 컨텍스트를 유지하여 메모리 누수를 유발함.
>```
>
>Context가 오래 지속되는 객체에는 Application 컨텍스트를 사용해야 함.
>
>```kotlin
>object Singleton {
>  lateinit var applicationContext: Context
>}
>```
>
>```kotlin
>// Application Context는 테마에 대한 리소스 정보가 없으므로 AlertDialog 사용에 부적합함.
>val dialog = AlertDialog.Builder(context.applicationContext)
>
>val dialog = AlertDialog.Builder(activityContext) // OK
>```
>
>```kotlin
>// 액티비티 참조를 유지하는 버튼 (메모리 누수 가능성)
>val button = Button(activity)
>activity.finish() // 액티비티는 소멸되었지만 버튼은 참조를 유지함.
>```
>
>```kotlin
>viewModelScope.launch {
>  val data = fetchData()
>  // UI 업데이트는 메인 스레드에서 수행해야 함.
>  withContext(Dispatchers.Main) {
>    Toast.makeText(context, "Data fetched", Toast.LENGTH_SHORT).show()
>  }
>}

<br>

**🛠️ Summary**<br>
Context를 효과적으로 사용하려면 상황에 따라 적절한 Context 유형을 잘 선택하는 것이 중요함.
메모리 누수로 이어질 수 있으므로 Activity 또는 Fragment의 Context를 해당 생명주기를 넘어 참조를 유지하지 않아야 함.<br>
항상 특정 작업에 맞는 올바른 유형의 Context를 선택하고, 백그라운드 스레드나 관련 컴포넌트가 소멸된 후에는 사용하지 않아야 함.<br>

>**💡Pro Tips for Mastery: ContextWrapper란 무엇인가요?** <br>









