# Android Framework

## Q0) 안드로이드 프레임워크란 무엇인가요?
스마트폰과 태블릿과 같은 모바일 기기를 위해 주로 설계된 **오픈소스 운영 체제**<br>
구글에 의해 개발 및 유지 관리되며 리눅스 커널에 기반함<br>

<br>

**안드로이드 OS의 주요 특징**
1. [오픈 소스](https://source.android.com/) 및 커스텀화
2. SDK를 이용한 애플리케이션 개발
3. 풍부한 앱 생태계
4. 멀티태스킹 및 리소스 관리
5. 다양한 하드웨어 지원

<br>

**안드로이드 아키텍처**
[안드로이드 플랫폼 아키텍처](https://developer.android.com/guide/platform)는 모듈식으로 계층되어 있으며, 여러 구성 요소로 이루어져 있음.

<p align="center">
  <img width="295" height="340" alt="android-architecture" src="https://github.com/user-attachments/assets/666b774d-1169-4796-a4ad-923a04ac4968" />
</p>

- **리눅스 커널 (Linux Kernel)**
  - 안드로이드 운영체제의 기반을 형성
  - 하드웨어 추상화를 처리하여 소프트웨어와 하드웨어 간의 원활한 상호 작용을 보장
    
<br>

- **하드웨어 추상화 계층 (Hardware abstraction layer (HAL)**
  - 안드로이드의 Java API 프레임워크를 기기 하드웨어에 연결하는 표준 인터페이스를 제공
    
<br>

- **안드로이드 런타임 및 코어 라이브러리 (Android Runtime (ART) 및 Core Libraries)**
  - Kotlin이나 Java에서 컴파일된 바이트코드를 사용하여 애플리케이션을 실행
  - 최적화된 성능을 위해 Ahead-of-Time (AOT)<sup>1</sup> 및 Just-in-Time (JIT)<sup>2</sup> 컴파일을 지원
    
<br>

- **네이티브 C/C++ 라이브러리 모음 (Native C/C++ Libraries)**
  - 안드로이드 프레임워크와 애플리케이션에서 성능 집약적인 작업을 위해 직접 사용됨
  - ex) OpenGL, SQLite
    
<br>

- **안드로이드 프레임워크 (Android Framework (APIS))**
  - 앱 개발을 위한 고수준 서비스와 API를 제공
  - 개발자가 안드로이드 시스템 기능을 효율적으로 활용할 수 있도록 지원
    
<br>

- **애플리케이션 (Applications)**
  - 시스템 앱과 안드로이드 SDK를 사용하여 생성된 서브파티 앱을 포함한 모든 유저 기반의 앱이 포함
  - 사용자에게 다양한 기능을 제공하고, 각종 시스템들을 원활하게 운용하기 위해 하위 계층과 통신

<br>

<sub>
<b>1) Ahead-of-Time (AOT) 컴파일</b><br>
  - 코드가 런타임 전에 기계 코드로 컴파일 되어 실행 중 Just-In-Time (JIT) 컴파일이 필요 없는 프로세스<br>
  - 최적화된 사전 컴파일된 바이너리를 생성하여 성능을 향상시키고 런타임 오버헤드를 줄임<br>
  <br>
<b>2)Just-In-Time (JIT) 컴파일</b><br>
  - 바이트코드가 실행 직전에 동적으로 기계 코드로 변환되는 런타임 프로세스<br>
  - 런타임 환경은 실제 실행 패턴을 기반으로 코드를 최적화하여 자주 사용되는 코드 경로의 성능을 향상<br>
</sub>

<br>

<br>

## Q1) 인텐트([Intent](https://developer.android.com/reference/android/content/Intent))란 무엇인가요?
수행될 작업에 대한 추상적인 설명<br>
Activity, Service, BroadcastReceiver가 통신할 수 있도록 하는 **메시징 객체 역할**<br>
브로드캐스트를 보내거나, Service를 시작하는데 사용됨<br>
또한 **컴포넌트 간에 데이터를 전달**할 수 있어 안드로이드 시스템에서 근본이 되는 요소<br>

<br>

**1. 명시적 Intent (Explicit Intent)**
- **정의**: 호출할 컴포넌트(Activity 또는 Service)를 직접 이름으로 지정하여 정확히 명시함
- **사용 사례**: 대상 컴포넌트를 알고 있을 때 사용됨
- **시나리오**: 동일한 앱 내에서 한 Activity에서 다른 Activity로 전환하는 경우<br>
  
```kotlin
val intent = Intent(this, TargetActivity::class.java)
startActivity(intent)
```

<br>

**2. 암시적 Intent (Implicit Intent)**
- **정의**: 특정 컴포넌트를 지정하지 않고 수행할 일반적인 작업을 선언함.<br>시스템은 액션(action), 카테고리(category), 데이터(data)를 기반으로 어떤 컴포넌트가 Intent를 처리할 수 있는지 결정
- **사용 사례**: 다른 앱이나 시스템 컴포넌트가 처리할 수 있는 작업을 수행하려 할 때 유용
- **시나리오**: 브라우저에서 웹 페이지를 열거나 다른 앱과 콘텐츠를 공유하는 경우 (시스템이 Intent를 처리할 앱을 결정함)

```kotlin
val intent = Intent(Intent.ACTION_VIEW)
intent.data = Uri.parse("https://www.example.com")
startActivity(intent)
```

<br>

**🛠️ Summary**<br>
명시적 Intent는 대상 컴포넌트가 알려진 내부 앱 내비게이션에 사용됨.<br>
암시적 Intent는 대상을 직접 지정하지 않고 외부 앱이나 다른 컴포넌트가 처리할 수 있는 작업에 사용됨.<br>

<br>

**💡 Pro Tips for Mastery : 인텐트 필터([Intent Filters](https://developer.android.com/guide/components/intents-filters))란 무엇인가요?** <br>
앱 컴포넌트가 링크 열기나 브로드캐스트 처리와 같은 **특정 Intent에 어떻게 응답할 수 있는지를 정의**<br>
Activity, Service 또는 BroadcastReceiver가 처리할 수 있는 **Intent 유형을 선언하는 필터** 역할을 하며, AndroidManifest.xml 파일에 명시됨<br>
각 intent filter는 들어오는 Intent와 정확히 일치시키기 위해 액션, 카테고리 및 데이터 유형을 포함할 수 있음<br>

<br>

<p align="center">
  <img width="858" height="396" alt="intent-filters" src="https://github.com/user-attachments/assets/7c8b7260-42e3-4dd6-b978-fe4a6a7a27dc" />
</p>

<br>

<br>

## Q2) PendingIntent의 목적은 무엇인가요?
다른 애플리케이션이나 시스템 컴포넌트가 애플리케이션을 대신하여 미리 정의된 Intent를 나중에 실행할 수 있는 권한을 부여하는 또 다른 종류의 Intent.<br>
알림이나 서비스와의 상호작용과 같이 앱의 수명 주기를 벗어나 트리거되어야하는 작업에 특히 유용함.<br>

<br>

**PendingIntent**의 주요 특징
일반 Intent의 래퍼(wrapper) 역할을 하여 앱의 생명주기를 넘어서 지속될 수 있도록 함.<br>
```kotlin
val intent = Intent(this, MyActivity::class.java)
// FLAG_IMMUTABLE 또는 FLAG_MUTABLE 플래그 지정 필수 (Android 12+)
val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
  PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
} else {
  PendingIntent.FLAG_UPDATE_CURRENT
}
val pendingIntent = PendingIntent.getActivity(
  this,
  0, // requestCode
  intent,
  pendingIntentFlags
)

val notification = NotificationCompat.Builder(this, CHANNEL_ID)
  .setContentTitle("Title")
  .setContentText("Content")
  .setSmallIcon(R.drawable.ic_notification)
  .setContentIntent(pendingIntent) // 알림을 탭했을 때 트리거됨
  .setAutoCancel(true) // 탭하면 알림 자동 삭제
  .build()

NotificationManagerCompat.from(this).notify(NOTIFICATION_ID, notification)
```

<br>

PendingIntent는 동작 방식과 시스템 또는 다른 컴포넌트와의 상호 작용 방식을 제어하는 다양한 플래그를 지원함.
- **FLAG_UPDATE_CURRENT**: 기존 PendingIntent를 새 데이터로 업데이트 함.
- **FLAG_CANCEL_CURRENT**: 새 PendingIntent를 만들기 전에 기존 PendingIntent를 취소함.
- **FLAG_IMMUTABLE**: PendingIntent를 변경 불가능하게 만들어 수신자가 수정하는 것을 방지함. (⭐️Android 12+)
- **FLAG_ONE_SHOT**: PendingIntent가 한 번만 사용될 수 있도록 보장함.

<br>

**사용 사례**
1. **노티피케이션 (Notifications)**: 사용자가 노티피케이션을 탭했을 때 Activity를 여는 것과 같은 작업을 허용함
2. **알람 (Alarms)**: AlarmManager를 사용하여 작업을 예약함
3. **서비스 (Services)**: 백그라운드 작업을 위해 ForegroundService 또는 BroadcastReceiver에 작업을 위임함

<br>

**보안 고려 사항**
악의적인 앱이 기본 Intent를 수정하는 것을 방지하기 위해 PendingIntent에는 항상 FLAG_IMMUTABLE을 설정해야 함.<br>

<br>

**🛠️ Summary**
PendingIntent는 앱이 활성 상태가 아닐 때에도 앱과 시스템 컴포넌트 또는 다른 앱 간의 원활한 통신을 가능하게 하는 안드로이드의 핵심 메커니즘.<br>
플래그와 권한을 신중하게 관리함으로써 지연된 작업의 안전하고 효울적인 실행을 보장할 수 있음.

<br>

<br>

## Q3)



